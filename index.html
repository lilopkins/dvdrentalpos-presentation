<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Presentation</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Film Rental System</h1>
					<h2>A Spring + React Project</h2>
				</section>
				<section>
					<h2>Introduction</h2>
					<p>Online Film rental store</p>

					<aside class="notes">
						Initially was planning on a point of sale system with self-service functionality.
						This plan changed due to time constraints and to fit the traning material better and became closer
						to an online Film Rental solution.

						Let's move forward to the implementation.
					</aside>
				</section>
				<section>
					<h2>Implementing Controllers</h2>
					<p>Controllers are implemented with a generic class.</p>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						@GetMapping("")
						public @ResponseBody Iterable<T> getPaged(Pageable p) {
							return repository.findAll(p);
						}

						@GetMapping("/{id}")
						public @ResponseBody Optional<T>
							get(@PathVariable(value = "id") I id) {

							return repository.findById(id);
						}

						public @ResponseBody T create(T obj) {
							repository.save(obj);
							return obj;
						}
						
						// ...
					</script></code></pre>

					<aside class="notes">
						The first stage was to implement a controller suitable to fetch data from the database.
						I decided to produce a generic controller that could be applied to any table in the database,
						accellerating future development and enabling the creation of generic tests to cover all
						database tables.
					</aside>
				</section>
				<section>
					<h2>Implementing Controllers</h2>
					<p>Creating a controller for a particular database table becomes easy&hellip;</p>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						@RestController
						@RequestMapping("/api/v1/actors")
						public class ActorsController
							extends ModelController<Actor, Integer, ActorRepository> {

							public ActorsController(ActorRepository repository) {
								super(repository);
							}

							// extensions could go here...
						}
					</script></code></pre>

					<aside class="notes">
						This meant that implementing the controller for a database table was straightfoward and enabled
						each controller to add more behaviour on top of the default behaviour defined in the generic class.
					</aside>
				</section>
				<section>
					<h2>Implementing Controllers</h2>
					<p>One key to enabling a clean UI</p>
					<pre><code class="hljs" data-trim data-line-numbers="3"><script type="text/template">
						public interface ActorRepository
							extends CrudRepository<Actor, Integer>,
									PagingAndSortingRepository<Actor, Integer> { }
					</script></code></pre>

					<aside class="notes">
						Using PagingAndSortingRepository provides extra functionality already built into Spring that
						takes data and separates it into pages and allows it to be sorted by any database column.
					</aside>
				</section>
				<section>
					<h2>Implementing Controllers</h2>
					<p>The result of this is a clean, efficient interface.</p>
					<iframe data-src="http://localhost:3000/#/browse" width="800" height="500" frameborder="0" marginwidth="0" marginheight="0" style="border:3px solid #666; background-color: white;" allowfullscreen></iframe>

					<aside class="notes">
						Demonstrate pages and sorting.
					</aside>
				</section>
				<section>
					<h2>Adding API Authentication</h2>

					<aside class="notes">
						I decided to challenge myself both in implementation and thorough testing by including
						an authentication system.
					</aside>
				</section>
				<section>
					<h2>Adding API Authentication</h2>
					<p>I also decided to add authentication</p>
					<ol>
						<li>The user submits a username and password to <code>/api/v1/auth/signin</code>.</li>
						<li>The username and password are verified.</li>
						<li>A token is issued, valid for 24 hours from the current IP address.</li>
					</ol>

					<aside class="notes">
						The system was intended to match the level of security present in the database already,
						as the staff table already has a username and password column.
						For customers and to hold the tokens, extra database tables are needed.
					</aside>
				</section>
				<section>
					<h2>Adding API Authentication</h2>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						CREATE TABLE `customer_logins` (
							`customer_id` SMALLINT(5) UNSIGNED NOT NULL,
							`username` VARCHAR(255) NOT NULL,
							`password_hash` VARCHAR(255) NOT NULL,
							PRIMARY KEY(`customer_id`),
							CONSTRAINT `fk_customer_login_id`
								FOREIGN KEY (`customer_id`)
								REFERENCES `customer` (`customer_id`)
								ON UPDATE CASCADE
								ON DELETE CASCADE
						);

						CREATE TABLE `customer_tokens` (
							`customer_id` SMALLINT(5) UNSIGNED NOT NULL,
							`token` VARCHAR(64) NOT NULL,
							`valid_from_ip` VARCHAR(64) NOT NULL,
							`valid_until` TIMESTAMP NOT NULL,
							PRIMARY KEY (`customer_id`, `token`),
							CONSTRAINT `fk_customer_token_customer_id`
								FOREIGN KEY (`customer_id`)
								REFERENCES `customer` (`customer_id`)
								ON UPDATE CASCADE
								ON DELETE CASCADE
						);

						CREATE TABLE `staff_tokens` (
							`staff_id` TINYINT(3) UNSIGNED NOT NULL,
							`token` VARCHAR(64) NOT NULL,
							`valid_from_ip` VARCHAR(64) NOT NULL,
							`valid_until` TIMESTAMP NOT NULL,
							PRIMARY KEY (`staff_id`, `token`),
							CONSTRAINT `fk_staff_token_staff_id`
								FOREIGN KEY (`staff_id`)
								REFERENCES `staff` (`staff_id`)
								ON UPDATE CASCADE
								ON DELETE CASCADE
						);
					</script></code></pre>

					<aside class="notes">
						Explain purpose of each table.
					</aside>
				</section>
				<section>
					<h2>Adding API Authentication</h2>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						String token = request.getHeader("x-token");

						if (token == null) {
							request.setAttribute(ATTRIBUTE, AuthenticationResult.NO_TOKEN);
							filterChain.doFilter(servletRequest, servletResponse);
							return;
						}

						Optional<StaffToken> staffToken = tokensRepository.findByToken(token);
						if (staffToken.isEmpty()) {
							request.setAttribute(ATTRIBUTE, AuthenticationResult.INVALID_TOKEN);
							filterChain.doFilter(servletRequest, servletResponse);
							return;
						}

						StaffToken st = staffToken.get();
						if (st.getValidUntil().isBefore(LocalDateTime.now())) {
							tokensRepository.delete(st);
							request.setAttribute(ATTRIBUTE, AuthenticationResult.EXPIRED_TOKEN);
							filterChain.doFilter(servletRequest, servletResponse);
							return;
						}
						if (!st.getValidFromIp().equals(request.getRemoteAddr())) {
							request.setAttribute(ATTRIBUTE, AuthenticationResult.TOKEN_USED_FROM_WRONG_ADDRESS);
							filterChain.doFilter(servletRequest, servletResponse);
							return;
						}

						request.setAttribute(ATTRIBUTE, AuthenticationResult.AUTHENTICATED);
					</script></code></pre>

					<aside class="notes">
						The main implementation of verifying the authentication on the API side is shown here.
						It's a step-by-step check trying to rule out having an authenticated user. If all checks
						pass then the user is considered authenticated.
					</aside>
				</section>
				<section>
					<h2>Testing Authentication</h2>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						Feature: Authentication
						As an API user, I need to be able to obtain an authentication token and validate it's currency.

						Scenario: Obtain a new token
							Given the JSON body: "{\"username\":\"Customer\", \"password\":\"12345\"}"
							When the endpoint "/api/v1/auth/signin" is accessed with a "POST" request
							Then the response has status 200

						Scenario: Validate a current token
							Given I have a valid API token
							When the endpoint "/api/v1/auth/status" is accessed with a "GET" request
							Then the response matches "\"AUTHENTICATED\""

						Scenario: Validate an expired token
							Given I have an expired API token
							When the endpoint "/api/v1/auth/status" is accessed with a "GET" request
							Then the response matches "\"EXPIRED_TOKEN\""

						Scenario: Attempt to use an invalid token
							Given I have an invalid API token
							When the endpoint "/api/v1/auth/status" is accessed with a "GET" request
							Then the response matches "\"INVALID_TOKEN\""

						Scenario: Make a request without a token
							When the endpoint "/api/v1/auth/status" is accessed with a "GET" request
							Then the response matches "\"NO_TOKEN\""
					</script></code></pre>

					<aside class="notes">
						Robust testing is vital for authentication. Given the need for a reliable environment, I decided to approach
						this testing with Cucumber.
						This tests both a successful authentication, and failed authentication routes.
					</aside>
				</section>
				<section>
					<h2>Testing Authentication</h2>
					<iframe data-src="file:///home/lily/Documents/dvdrentalpos/target/cucumber-report.html" width="800" height="500" frameborder="0" marginwidth="0" marginheight="0" style="border:3px solid #666; background-color: white;" allowfullscreen></iframe>
					
					<aside class="notes">
						The result of this cucumber testing is a set of passes, which gives a good indication that the
						authentication works as intended.
					</aside>
				</section>
				<section>
					<h2>Testing the API</h2>
					<p>Again, generic tests to cover each database table quickly, specialised test developed to fill in gaps.</p>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						@Test
						public void testGet() {
							T obj = getTestObject();
							when(repository.findById(obj.getId())).thenReturn(Optional.of(obj));

							Optional<T> opt = controller.get(obj.getId());
							verify(repository).findById(obj.getId());

							assertTrue(opt.isPresent(), "object not fetched");
							assertEquals(obj, opt.get(), "object not correct");
						}
					</script></code></pre>
				</section>
				<section>
					<h2>Cucumber + Selenium Testing</h2>
					<pre><code class="hljs" data-trim data-line-numbers><script type="text/template">
						@Selenium
						Scenario: View a film
						  When I navigate to "/film/1"
						  Then "h1.title" is visible
						  And "ul" is visible
						  And the robot quits
					  
						@Selenium
						Scenario: View list of actors
						  When I navigate to "/actors"
						  Then A pageable element is visible
						  And the robot quits
					</script></code></pre>

					<aside class="notes">
						For frontend testing, Selenium automates the browser interactions, but Cucumber provides
						a clean, concise way of structuring these tests.
					</aside>
				</section>
				<section>
					<h2>Testing Outcomes</h2>
					<p>63.4% coverage</p>
					<p>(>90% without authentication)</p>

					<aside class="notes">
						Although coverage shows as fairly low, this is due to it being impossible to test the authenticated methods
						properly in a mocked environment.
						There are Cucumber tests covering these cases, which - if included with code coverage (which is due to a
						limitation of Maven) - coverage would be higher.
						Prior to API authentication, coverage was over 99%.
					</aside>
				</section>
				<section>
					<iframe data-src="http://localhost:3000/#/" width="1280" height="600" frameborder="0" marginwidth="0" marginheight="0" style="border:3px solid #666; background-color: white;" allowfullscreen></iframe>

					<aside class="notes">
						Demonstrate Films, Actors, Selecting an actor, Selecting a film
						Sign in, show edit features
						Sign in as customer and rent a film - at the moment this isn't implemented!
					</aside>
				</section>
				<section>
					<p>Questions welcome.</p>
					<p>See the project yourself: <a href="https://hpkns.uk/tsifilms">hpkns.uk/tsifilms</a></p>
					<p><small>(Azure can be quite slow!)</small></p>
					<p>Browse the source: <a href="https://hpkns.uk/tsisource">hpkns.uk/tsisource</a></p>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
